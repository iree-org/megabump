#!/usr/bin/env python
# Copyright 2023 The IREE Authors
#
# Licensed under the Apache License v2.0 with LLVM Exceptions.
# See https://llvm.org/LICENSE.txt for license information.
# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

import argparse
import subprocess
import sys

import megabump_utils as mb
from current_state import CurrentState 

LLVM_REPO_DIR = mb.llvm_submodule_path

def do_next(args):
    fetch(args)
    state = CurrentState(args)
    if not state.new_commits:
        print(f"Up to date! Not starting.")
        sys.exit(99)

    next_commit, next_desc = state.find_next_commit()
    index_commit = state.index_of_next_commit(next_commit)
    print(
        f"==> Advancing to next LLVM commit ({index_commit} "
        f"of {len(state.new_commits)}):"
    )
    print(f"  {next_commit}: {next_desc}")
    if state.is_clean:
        print("Resetting LLVM head (branch is clean)")
        mb.git_reset(next_commit, repo_dir=LLVM_REPO_DIR)
    else:
        print("Rebasing LLVM")
        mb.git_rebase(next_commit, remote="upstream", repo_dir=LLVM_REPO_DIR)
    mb.git_create_commit(
        message=(
            f"Advance LLVM to {next_commit}: {next_desc} "
            f"({index_commit} of {len(state.new_commits)})"
        ),
        add_all=True,
        repo_dir=mb.iree_path,
    )

    if not args.no_export:
        print("Exporting submodule state to remote fork")
        subprocess.check_call(
            [sys.executable, str(mb.scripts_path / "export_submodule_head")],
            cwd=mb.scripts_path,
        )


def do_range(args):
    logs = mb.git_log_range(refs=(f"{args.from_ref}^1..{args.to_ref}",), repo_dir=LLVM_REPO_DIR)
    for commit, desc in logs:
        print(f"{commit} : {desc}")


def do_status(args):
    fetch(args)
    state = CurrentState(args)
    print(f"==> llvm-project is currently at {state.current_summary}:")
    if state.is_clean:
        print(f"  : Current commit is clean (no patches)")
    else:
        merge_base_summary = mb.git_commit_summary(
            state.merge_base_commit, repo_dir=LLVM_REPO_DIR
        )
        print(
            f"  : Current commit has diverging patches with base {state.merge_base_commit} ({merge_base_summary})"
        )

    # Compute the different commits.
    print(
        f"==> {len(state.new_commits)} affecting commits between upstream head and current:"
    )
    for commit, desc in state.new_commits:
        print(f"  {commit}: {desc}")


def fetch(args):
    print("==> Fetching origin and upstream revisions...")
    setup_remotes(args)
    mb.git_fetch(repository="origin")
    mb.git_fetch(repository="origin", repo_dir=LLVM_REPO_DIR)
    mb.git_fetch(repository="upstream", repo_dir=LLVM_REPO_DIR)

def do_fetch(args):
    fetch(args)


def setup_remotes(args):
    # We need to know what the real upstream repo is.
    mb.git_setup_remote(
        "upstream", "https://github.com/llvm/llvm-project.git", repo_dir=LLVM_REPO_DIR
    )


def main(args):
    if args.sub_command == "next":
        do_next(args)
    elif args.sub_command == "range":
        do_range(args)
    elif args.sub_command == "status":
        do_status(args)
    elif args.sub_command == "fetch":
        do_fetch(args)
    else:
        raise ValueError(f"Unrecognized sub-command {args.sub_command}")


def parse_arguments(argv):
    parser = argparse.ArgumentParser(description="IREE LLVM Revision Management")
    subparsers = parser.add_subparsers(
        help="sub-command help", required=True, dest="sub_command"
    )
    next_parser = subparsers.add_parser("next")
    next_parser.add_argument(
        "--advance-to", default=None, nargs="?", help="Advance to the given LLVM commit"
    )
    next_parser.add_argument(
        "--no-export",
        default=False,
        action="store_true",
        help="Disable export of the submodule commit",
    )
    status_parser = subparsers.add_parser("status")
    fetch_parser = subparsers.add_parser("fetch")
    range_parser = subparsers.add_parser("range")
    range_parser.add_argument("from_ref", help="Starting commit")
    range_parser.add_argument("to_ref", help="Ending commit")

    args = parser.parse_args(argv)
    return args


if __name__ == "__main__":
    main(parse_arguments(sys.argv[1:]))
